package Ahorcado.model;

import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import javax.imageio.ImageIO;
import javax.swing.JOptionPane;

/**
 * Modelo del juego del Ahorcado
 * Almacena únicamente el estado del juego
 * 
 * @author Inés Jaso Pernod
 * @author Natalia Tauste Rubio
 */
public class AhorcadoModel {

    private String palabraSecreta;
    private Set<Character> letrasUsadas;
    private int fallos;
    private int puntuacion;
    private BufferedImage imagenAhorcado;
    private String rutaImagen;
    private Persona[] p_vec = new Persona[10];
    public static final int MAX_FALLOS = 5;
    private static int num_personas = 0;

    /*
    * Constructor del model sin parametros
    */
    public AhorcadoModel() {
        this.palabraSecreta = "";
        this.letrasUsadas = new HashSet<>();
        this.fallos = 0;
        this.puntuacion = 0;
        
        try {
            rutaImagen = "Inicio.png"; // ruta desde la raíz del classpath
            java.net.URL urlImagen = getClass().getResource(rutaImagen);
            if (urlImagen != null) {
                imagenAhorcado = ImageIO.read(urlImagen);
            } else {
                System.err.println("No se encontró la imagen '" + rutaImagen + "'");
            }
        } catch (IOException e) {
            System.err.println("Problemas leyendo la imagen '" + rutaImagen + "'.");
            System.err.println("Motivo: " + e.getLocalizedMessage());
        }
    }

    /*
    * Constructor del model con parametros
    */
    public AhorcadoModel(String palabra) {
        this.palabraSecreta = palabra.toUpperCase();
        this.letrasUsadas = new HashSet<>();
        this.fallos = 0;
        this.puntuacion = 0;
    }

    /**
     * Procesa una letra introducida por el usuario en el estilo 1
     */
    public boolean probarLetraEstilo1(char letra) {
        letra = Character.toUpperCase(letra);
        puntuacion++;

        if (letrasUsadas.contains(letra)) {
            return false;
        }

        letrasUsadas.add(letra);

        if (!palabraSecreta.contains(String.valueOf(letra))) {
            fallos++;
            cargarImagen("/Estilos/Estilo1/Fallo" + fallos + ".png");
            return false;
        }
        return true;
    }

    /**
     * Procesa una letra introducida por el usuario en el estilo 2
     */
    public boolean probarLetraEstilo2(char letra) {
        letra = Character.toUpperCase(letra);
        puntuacion++;

        if (letrasUsadas.contains(letra)) {
            return false;
        }

        letrasUsadas.add(letra);

        if (!palabraSecreta.contains(String.valueOf(letra))) {
            fallos++;
            cargarImagen("/Estilos/Estilo2/Fallo" + fallos + ".png");
            return false;
        }
        return true;
    }

    /**
     * Procesa una letra introducida por el usuario en el estilo 3
     */
    public boolean probarLetraEstilo3(char letra) {
        letra = Character.toUpperCase(letra);
        puntuacion++;

        if (letrasUsadas.contains(letra)) {
            return false;
        }

        letrasUsadas.add(letra);

        if (!palabraSecreta.contains(String.valueOf(letra))) {
            fallos++;
            cargarImagen("/Estilos/Estilo3/Fallo" + fallos + ".png");
            return false;
        }
        return true;
    }

    /**
     * Carga la imagen del ahorcado según los fallos
     */
    private void cargarImagen(String ruta) {
        this.rutaImagen = ruta;
        try {
            imagenAhorcado = ImageIO.read(getClass().getResourceAsStream(ruta));
        } catch (IOException | IllegalArgumentException e) {
            System.err.println("Error cargando imagen: " + ruta);
        }
    }

    // GETTERS

    public BufferedImage getImagenAhorcado() {
        return imagenAhorcado;
    }

    public int getFallos() {
        return fallos;
    }

    public int getPuntuacion() {
        return puntuacion;
    }

    public Set<Character> getLetrasUsadas() {
        return letrasUsadas;
    }

    /**
     * Clase persona que contiene la informacion de una persona
     */
    public class Persona{
        private int intentos;
        private int ganar;
        private String nombre;
        private static int num = 0;
        
        /**
         * Constructor por defecto
         * @param n Nombre
         * @param ganar Si ha ganado o no
         * @param intentos Numero de intentos
         */
        public Persona(String n, int ganar, int intentos){
            this.nombre = n;
            this.ganar = ganar;
            this.intentos = intentos;
            num++;
        }

        /**
         * Getter de nombre
         * @return 
         */
       public String getNombre(){
           return this.nombre;
       }

       /**
        * Getter de intentos
        * @return 
        */
       public int getIntentos(){
           return this.intentos;
       }

       /**
        * Getter de si ha ganado o no
        * @return 
        */
       public int getGanar(){
           return this.ganar;
       }

       /**
        * Getter de numero de personas
        * @return 
        */
       public int getNum(){
           return num;
       }
    }

    /**
     * Funcion para agregar una persona en el array de jugadores
     * @param ganar si ha ganado o perdido
     * @param veces cuantos intentos
     */
    public void agregarRanking(int ganar, int veces){
        Persona p = new Persona(JOptionPane.showInputDialog(null,
                "Introduce el nombre del jugador 2 "), ganar, veces);
        Persona aux;
        
        p_vec[num_personas] = p;
        num_personas++; // Se suma 1 al total de personas que son contenidas en el array
        
        for(int i = 0; i < num_personas; i++){ // Se ordenan las entradas cada vez que se introduce un dato
            for(int j = 0; j < num_personas; j++){
                if(p_vec[j].getIntentos() > p_vec[i].getIntentos())
                {
                    aux = p_vec[i];
                    p_vec[i] = p_vec[j];
                    p_vec[j] = aux;
                }
            }
        }
    }

    /**
     * Devuelve el vector personas
     * @return 
     */
    public Persona[] mostrarRanking(){
        return p_vec;
    }
}